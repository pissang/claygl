import * as util from '../core/util';
import Geometry from '../Geometry';
import GeometryBase, {
  AttributeSize,
  AttributeType,
  AttributeValue,
  GeometryAttribute
} from '../GeometryBase';
import BoundingBox from '../math/BoundingBox';
import Vector3 from '../math/Vector3';

const META = {
  version: 1.0,
  type: 'Geometry',
  generator: 'util.transferable.toObject'
};

interface DataObject {
  meta: typeof META;
  dynamic: boolean;
  boundingBox: {
    min: number[];
    max: number[];
  };
  indices?: Uint16Array | Uint32Array;
  attributes: Record<
    string,
    {
      name: string;
      type: AttributeType;
      size: AttributeSize;
      semantic?: string;
      value: AttributeValue;
    }
  >;
}

/**
 * Convert geometry to a object containing transferable data
 * @param {Geometry} geometry geometry
 * @param {Boolean} shallow whether shallow copy
 * @returns {Object} { data : data, buffers : buffers }, buffers is the transferable list
 */
export function toObject(geometry: GeometryBase, shallow?: boolean) {
  const data = {
    meta: util.assign({}, META)
  } as DataObject;
  //transferable buffers
  const buffers: ArrayBuffer[] = [];

  //dynamic
  data.dynamic = geometry.dynamic;

  //bounding box
  if (geometry.boundingBox) {
    data.boundingBox = {
      min: geometry.boundingBox.min.toArray(),
      max: geometry.boundingBox.max.toArray()
    };
  }

  //indices
  if (geometry.indices && geometry.indices.length > 0) {
    data.indices = copyIfNecessary(geometry.indices, shallow);
    buffers.push(data.indices!.buffer);
  }

  //attributes
  const geoAttributes = geometry.attributes;
  const dataAttributes = (data.attributes = {} as DataObject['attributes']);
  for (const p in geoAttributes) {
    if (util.hasOwn(geoAttributes, p)) {
      const attr = geoAttributes[p];
      //ignore empty attributes
      if (attr && attr.value && attr.value.length > 0) {
        dataAttributes[p] = copyAttribute(attr, shallow);
        buffers.push((dataAttributes[p].value as Float32Array).buffer);
      }
    }
  }

  return {
    data,
    buffers
  };
}

/**
 * Reproduce a geometry from object generated by toObject
 * @param {Object} object object generated by toObject
 * @returns {Geometry} geometry
 */
export function toGeometry(object: DataObject) {
  if (!object.meta || object.meta.generator !== META.generator) {
    throw new Error(
      '[util.transferable.toGeometry] the object is not generated by util.transferable.'
    );
  }

  //basic options
  const options = {
    dynamic: object.dynamic,
    indices: object.indices
  };

  const geometry = new Geometry(options);
  const bbox = object.boundingBox;

  if (bbox) {
    const min = new Vector3().setArray(bbox.min);
    const max = new Vector3().setArray(bbox.max);
    geometry.boundingBox = new BoundingBox(min, max);
  }
  //attributes
  for (const p in object.attributes) {
    if (util.hasOwn(object.attributes, p)) {
      const attrObj = object.attributes[p];
      const attr = geometry.createAttribute(
        attrObj.name,
        attrObj.type,
        attrObj.size,
        attrObj.semantic
      );
      attr.value = attrObj.value;
    }
  }

  return geometry;
}

function copyAttribute(attr: GeometryAttribute, shallow?: boolean) {
  return {
    name: attr.name,
    type: attr.type,
    size: attr.size,
    semantic: attr.semantic,
    value: copyIfNecessary(attr.value, shallow)
  };
}

function copyIfNecessary(arr: any, shallow?: boolean) {
  return !shallow ? new arr.constructor(arr) : arr;
}
